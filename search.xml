<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>拥有最多糖果的孩子</title>
    <url>/posts/2571685219/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h4 id="1431-拥有最多糖果的孩子"><a href="#1431-拥有最多糖果的孩子" class="headerlink" title="1431. 拥有最多糖果的孩子"></a><a href="https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/">1431. 拥有最多糖果的孩子</a></h4><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。</p>
<p>对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。</p>
<a id="more"></a>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：candies = [2,3,5,1,3], extraCandies = 3</span><br><span class="line">输出：[true,true,true,false,true] </span><br><span class="line">解释：</span><br><span class="line">孩子<span class="number"> 1 </span>有<span class="number"> 2 </span>个糖果，如果他得到所有额外的糖果（3个），那么他总共有<span class="number"> 5 </span>个糖果，他将成为拥有最多糖果的孩子。</span><br><span class="line">孩子<span class="number"> 2 </span>有<span class="number"> 3 </span>个糖果，如果他得到至少<span class="number"> 2 </span>个额外糖果，那么他将成为拥有最多糖果的孩子。</span><br><span class="line">孩子<span class="number"> 3 </span>有<span class="number"> 5 </span>个糖果，他已经是拥有最多糖果的孩子。</span><br><span class="line">孩子<span class="number"> 4 </span>有<span class="number"> 1 </span>个糖果，即使他得到所有额外的糖果，他也只有<span class="number"> 4 </span>个糖果，无法成为拥有糖果最多的孩子。</span><br><span class="line">孩子<span class="number"> 5 </span>有<span class="number"> 3 </span>个糖果，如果他得到至少<span class="number"> 2 </span>个额外糖果，那么他将成为拥有最多糖果的孩子。</span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、求得candies最大值<span class="built_in">max</span> (是否可以使用排序算法）</span><br><span class="line"><span class="number">2</span>、循环 每个孩子的糖果数 + extraCandies与<span class="built_in">max</span>比较，大于等于则为<span class="literal">true</span>,否则为<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array1431</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Boolean&gt; <span class="title">kidsWithCandies</span><span class="params">(<span class="keyword">int</span>[] candies, <span class="keyword">int</span> extraCandies)</span> </span>&#123;</span><br><span class="line">        List&lt;Boolean&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//1、最大值</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candies.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (candies[i] &gt; max)&#123;</span><br><span class="line">                max = candies[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candies.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (candies[i] + extraCandies &gt;= max)&#123;</span><br><span class="line">                res.add(<span class="keyword">true</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Array1431 array1431 = <span class="keyword">new</span> Array1431();</span><br><span class="line">        List&lt;Boolean&gt; res = array1431.kidsWithCandies(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>&#125;, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++)&#123;</span><br><span class="line">            System.out.print(res.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>数组</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>一维数组的动态和</title>
    <url>/posts/3840914265/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="1480-一维数组的动态和"><a href="#1480-一维数组的动态和" class="headerlink" title="1480. 一维数组的动态和"></a><a href="https://leetcode-cn.com/problems/running-sum-of-1d-array/">1480. 一维数组的动态和</a></h2><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。</p>
<p>请返回 nums 的动态和。</p>
<a id="more"></a>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：[1,3,6,10]</span><br><span class="line">解释：动态和计算过程为 [1, 1<span class="string">+2</span>, 1<span class="string">+2</span><span class="string">+3</span>, 1<span class="string">+2</span><span class="string">+3</span><span class="string">+4</span>] 。</span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>在看到此题后的第一思路就是借用一个变量sum存储前n个数值的和并将sum赋给数组result中。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] runningSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            result[i] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>数组</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>好数对的数目</title>
    <url>/posts/1908178651/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h4 id="1512-好数对的数目"><a href="#1512-好数对的数目" class="headerlink" title="1512. 好数对的数目"></a><a href="https://leetcode-cn.com/problems/number-of-good-pairs/">1512. 好数对的数目</a></h4><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>给你一个整数数组 nums 。</p>
<p>如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i &lt; j ，就可以认为这是一组 好数对 。</p>
<p>返回好数对的数目</p>
<a id="more"></a>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,1,1,3]</span><br><span class="line">输出：4</span><br><span class="line">解释：有<span class="number"> 4 </span>组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从<span class="number"> 0 </span>开始</span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">暴力循环、双重循环，但注意第二重循环的起点是第一层循环i，避免重复比较</span><br></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array1512</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIdenticalPairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] ==  nums[j] &amp;&amp; i &lt; j)&#123;</span><br><span class="line">                    res ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>数组</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/posts/3898435914/</url>
    <content><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树是树的一种特殊形式。二叉树每个节点最多有两个孩子节点（可以为1个或者没有孩子节点）。二叉树的两个孩子节点，左侧被称为左孩子，右侧被称为右孩子。</p>
<h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上，那么这个树就是满二叉树。</p>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同。则这个二叉树为完全二叉树。</p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树的遍历方式分为深度优先遍历和广度优先遍历方式。这两个概念不止局限于二叉树，它们更是一种抽象的算法思想，决定了访问某些复杂数据结构的顺序。在访问树、图或其它一些复杂数据结构时，这两个概念经常被用到。</p>
<h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><p>深度优先即”一头扎到底“的访问方式。</p>
<h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><p>前序遍历输出顺序是根节点、左子树、右子树。</p>
<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><p>中序遍历输出顺序是左子树、根节点、右子树。</p>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><p>后序遍历输出顺序是左子树、右子树、根节点。</p>
<h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><h5 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h5><p>按照从根节点到叶子节点的层次关系，一层一层横向遍历各个节点。（需要借助与队列实现）</p>
<h3 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h3><p>二叉堆本质上是一种完全二叉树，它分为最大堆和最小堆两种类型。</p>
<h4 id="最大堆"><a href="#最大堆" class="headerlink" title="最大堆"></a>最大堆</h4><p>最大堆的任何一个父节点的值，都大于或等于它左、右孩子节点的值。</p>
<h4 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h4><p>最小堆的任何一个父节点的值，都小于或等于它左、右孩子节点的值。</p>
<p>二叉堆的根节点叫作堆顶。最大堆和最小堆的特点决定了：最大堆的堆顶是整个堆中的最大元素；最小堆的堆顶是整个堆中的最小元素。</p>
<p>二叉树虽然是一个完全二叉树，但它的存储方式并不是链式存储，而是顺序存储。即二叉堆的所有节点都存储在数组中。</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>最富有客户的资产总量</title>
    <url>/posts/2894011118/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="1672-最富有客户的资产总量"><a href="#1672-最富有客户的资产总量" class="headerlink" title="1672. 最富有客户的资产总量"></a><a href="https://leetcode-cn.com/problems/richest-customer-wealth/">1672. 最富有客户的资产总量</a></h2><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>给你一个 m x n 的整数网格 accounts ，其中 accounts[i][j]是第 i 位客户在第 j 家银行托管的资产数量。返回最富有客户所拥有的 资产总量 。</p>
<p>客户的 资产总量 就是他们在各家银行托管的资产数量之和。最富有客户就是 资产总量 最大的客户。</p>
<a id="more"></a>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：accounts = [[1,2,3],[3,2,1]]</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">第<span class="number"> 1 </span>位客户的资产总量 =<span class="number"> 1 </span>+<span class="number"> 2 </span>+<span class="number"> 3 </span>= 6</span><br><span class="line">第<span class="number"> 2 </span>位客户的资产总量 =<span class="number"> 3 </span>+<span class="number"> 2 </span>+<span class="number"> 1 </span>= 6</span><br><span class="line">两位客户都是最富有的，资产总量都是<span class="number"> 6 </span>，所以返回<span class="number"> 6 </span>。</span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">求得矩阵每行的值，并比较大小。可以先定义<span class="built_in">max</span>变量，</span><br><span class="line">之后利用双重循环:</span><br><span class="line">(<span class="number">1</span>) 行循环，每位客户</span><br><span class="line">(<span class="number">2</span>) 列循环，计算每位客户的资产总量。</span><br><span class="line">计算的每位客户的资产总量与<span class="built_in">max</span>比较，记录最大的值，最后输出。</span><br></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array1672</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumWealth</span><span class="params">(<span class="keyword">int</span>[][] accounts)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 在Java中，二维数组length是行的个数</span></span><br><span class="line">        <span class="keyword">int</span> length = accounts.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> col = accounts[i].length;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                temp += accounts[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; res)&#123;</span><br><span class="line">                res = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Array1672 array1672 = <span class="keyword">new</span> Array1672();</span><br><span class="line">        <span class="keyword">int</span>[][] accounts = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        System.out.println(array1672.maximumWealth(accounts));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>数组</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
</search>
